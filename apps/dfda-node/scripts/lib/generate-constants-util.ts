import { Pool, QueryResult, QueryResultRow } from 'pg';
import * as fs from 'fs/promises';
import * as path from 'path';
import * as dotenv from 'dotenv';
import type { Database } from '@/lib/database.types'; // Central type import

// Load environment variables
dotenv.config({ path: path.resolve(__dirname, '../../.env') }); // Adjust path relative to the final script location

// Helper type to extract keys of tables that have a 'Row' property
type TablesWithRow<Schema extends keyof Database> = {
    [K in keyof Database[Schema]['Tables'] as Database[Schema]['Tables'][K] extends { Row: any } ? K : never]: any
};

// Helper type to safely extract the Row type from a table definition
type ExtractRowType<T> = T extends { Row: infer R } ? R : never;

// Simplified interface - RowType is now just used internally
interface GenerateConstantsOptions<
    Schema extends keyof Database,
    Table extends keyof TablesWithRow<Schema>
> {
    tableName: Table;
    dbSchema?: Schema;
    outputFilePath: string;
    typeImportPath?: string;
    rowTypeName: string;
    idsConstantName: string;
    dataConstantName: string;
    // Use generic `keyof any` here, validation happens inside the function
    keyGenerationColumn: keyof any;
    idColumn?: keyof any;
    orderByColumn?: keyof any;
    columnsToExclude?: (keyof any | string)[];
    numericColumns?: (keyof any)[];
}

// Helper function to generate constant keys (e.g., HEALTH_AND_PHYSIOLOGY from 'Health and Physiology')
function generateConstantKey(value: unknown): string {
    if (typeof value !== 'string') {
        return 'INVALID_KEY';
    }
    return value.toUpperCase().replace(/[^A-Z0-9_]/g, '_').replace(/_+/g, '_');
}

export async function generateConstantsFile<
    Schema extends keyof Database = 'public',
    Table extends keyof TablesWithRow<Schema> = keyof TablesWithRow<Schema>
>(
    options: GenerateConstantsOptions<Schema, Table> // Use simplified options type
): Promise<void> {

    // Resolve the final schema and table names *first*
    const resolvedSchema = options.dbSchema ?? 'public' as Schema;
    const resolvedTableName = options.tableName;

    // Define the specific Row type using the ExtractRowType helper
    type ConcreteRow = ExtractRowType<Database[typeof resolvedSchema]['Tables'][typeof resolvedTableName]> & QueryResultRow;

    // Validate and extract options, casting key columns to the ConcreteRow type
    const { 
        outputFilePath,
        typeImportPath = '@/lib/database.types',
        rowTypeName,
        idsConstantName,
        dataConstantName,
        keyGenerationColumn, // Keep as keyof any for now, used with ConcreteRow below
        idColumn = 'id', // Default to 'id' string
        orderByColumn = idColumn,
        columnsToExclude = ['created_at', 'updated_at'],
        numericColumns = [],
    } = options;
    
    // Type assertion for safety - ensuring provided keys are valid for the ConcreteRow
    const typedKeyGenColumn = keyGenerationColumn as keyof ConcreteRow;
    const typedIdColumn = idColumn as keyof ConcreteRow;
    const typedOrderByColumn = orderByColumn as keyof ConcreteRow;
    const typedColumnsToExclude = columnsToExclude as (keyof ConcreteRow | string)[];
    const typedNumericColumns = numericColumns as (keyof ConcreteRow)[];


    const dbUrl = process.env.DATABASE_URL;
    if (!dbUrl) {
        throw new Error('DATABASE_URL environment variable is not set.');
    }

    const pool = new Pool({ connectionString: dbUrl });
    let client;

    console.log(`Starting generation for ${String(resolvedSchema)}.${String(resolvedTableName)}...`);

    try {
        client = await pool.connect();
        console.log(`Connected to database for ${String(resolvedTableName)}.`);

        const qualifiedTableName = `${String(resolvedSchema)}.${String(resolvedTableName)}`;
        const orderByClause = typedOrderByColumn ? `ORDER BY \"${String(typedOrderByColumn)}\"` : ''; // Use typedOrderByColumn
        const query = `SELECT * FROM ${qualifiedTableName} ${orderByClause}`;

        const result: QueryResult<ConcreteRow> = await client.query(query); // Use ConcreteRow
        const rows = result.rows;

        if (!rows || rows.length === 0) {
            console.warn(`No rows found in ${qualifiedTableName}. Output file will be empty.`);
            // Optionally write an empty file or just return
            await fs.writeFile(outputFilePath, `// No data found in ${qualifiedTableName}\n`, 'utf8');
            return;
        }

        console.log(`Found ${rows.length} rows in ${qualifiedTableName}.`);

        // --- Generate TypeScript code ---
        let tsCode = `// Source table: ${qualifiedTableName}\n`;
        tsCode += `// Do not edit this file manually, it will be overwritten.\n\n`;
        tsCode += `import type { Database } from '${typeImportPath}';\n\n`;
        // Construct the type path string dynamically using resolved names
        const typePathString = `Database['${String(resolvedSchema)}']['Tables']['${String(resolvedTableName)}']['Row']`;
        tsCode += `type ${rowTypeName} = ${typePathString};\n\n`;

        // Generate IDS constant
        tsCode += `export const ${idsConstantName} = {\n`;
        const localIdsMap: Record<string, any> = {}; // Store generated keys and their corresponding IDs
        rows.forEach(row => {
            const key = generateConstantKey(row[typedKeyGenColumn]); // Use typedKeyGenColumn
            const idValue = row[typedIdColumn]; // Use typedIdColumn
            if (key !== 'INVALID_KEY' && idValue !== undefined) {
                 // Ensure ID is stringified if it's not already
                tsCode += `  ${key}: '${String(idValue)}', // ${String(row[typedKeyGenColumn])}\n`;
                localIdsMap[key] = idValue;
            } else {
                console.warn(`Could not generate valid key or find ID for row:`, row);
            }
        });
        tsCode += `} as const;\n\n`;

        // Generate DATA constant - Use Partial<RowTypeName> to allow missing optional properties
        tsCode += `export const ${dataConstantName}: Record<string, Partial<${rowTypeName}>> = {\n`;
        rows.forEach(row => {
            const key = generateConstantKey(row[typedKeyGenColumn]); // Use typedKeyGenColumn
            const idValue = row[typedIdColumn]; // Use typedIdColumn
            const idConstantRef = `${idsConstantName}.${key}`;

            // Create a filtered data object
            const filteredData: Record<string, any> = {};
            // Cast row to Record<string, any> for Object.entries
            for (const [propKey, propValue] of Object.entries(row as Record<string, any>)) {
                // Exclude specified columns and null values (unless it's a numeric column that should be 0)
                if (!typedColumnsToExclude.includes(propKey as keyof ConcreteRow) && // Use typedColumnsToExclude
                    (propValue !== null || (typedNumericColumns.includes(propKey as keyof ConcreteRow) && propValue === 0))) // Use typedNumericColumns
                {
                    if (typedNumericColumns.includes(propKey as keyof ConcreteRow) && propValue !== null) { // Use typedNumericColumns
                        // Ensure numeric columns are parsed as numbers
                        filteredData[propKey] = parseFloat(String(propValue));
                    } else {
                        filteredData[propKey] = propValue;
                    }
                }
            }

            // Stringify the filtered data
            let dataJsonString = JSON.stringify(filteredData, null, 2);

            // Special handling for numeric columns to remove quotes after stringify
            if (typedNumericColumns.length > 0) { // Use typedNumericColumns
                 // Create a regex pattern dynamically based on numericColumns
                 const numericKeysPattern = typedNumericColumns.map(col => String(col)).join('|'); // Use typedNumericColumns
                 const regex = new RegExp(`"(${numericKeysPattern})":\\s*"(-?\\d*\\.?\\d+)"`, 'g');
                 dataJsonString = dataJsonString.replace(regex, '"$1": $2');
            }

            // Use the generated constant key if it maps correctly, otherwise use the raw ID
            if (localIdsMap[key] === idValue) {
                tsCode += `  [${idConstantRef}]: ${dataJsonString},\n`;
            } else {
                console.warn(`ID/Key mismatch for data object: ID ${String(idValue)}, Key ${key}. Using raw ID as key.`);
                tsCode += `  '${String(idValue)}': ${dataJsonString}, // Fallback key\n`;
            }
        });
        tsCode += `};\n`;

        // Ensure the output directory exists
        await fs.mkdir(path.dirname(outputFilePath), { recursive: true });

        // Write the file
        await fs.writeFile(outputFilePath, tsCode, 'utf8');
        console.log(`Successfully generated constants file at ${outputFilePath}`);

    } catch (error) {
        console.error(`Error generating constants for ${String(resolvedTableName)}:`, error); // Use resolvedTableName
        process.exit(1); // Exit with error code
    } finally {
        if (client) {
            client.release();
        }
        await pool.end();
        console.log(`Database connection closed for ${String(resolvedTableName)}.`); // Use resolvedTableName
    }
}
