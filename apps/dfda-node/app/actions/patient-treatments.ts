"use server"

import { createClient } from '@/lib/supabase/server'
import type { Database } from '@/lib/database.types'
import { revalidatePath } from 'next/cache'
import { logger } from '@/lib/logger'

// Import related types if needed
export type PatientTreatmentInsert = Database['public']['Tables']['patient_treatments']['Insert']
export type UserVariableInsert = Database['public']['Tables']['user_variables']['Insert']

// Type for the input data when selecting treatments in the UI
// Assuming it provides global treatment ID and maybe name
export type SelectedTreatment = {
  treatmentId: string; 
  treatmentName: string;
}

// Define a type for the PatientTreatment data fetched with treatment name
export type PatientTreatmentWithName = Database['public']['Tables']['patient_treatments']['Row'] & {
  treatments: {
    global_variables: { name: string | null } | null
  } | null
}

// Removed TreatmentEntry and ConditionTreatmentState interfaces

// --- Server Action --- 

// Action to get all treatments for a patient
export async function getPatientTreatmentsAction(patientId: string): Promise<PatientTreatmentWithName[]> {
  const supabase = await createClient()
  logger.info('Fetching treatments for patient', { patientId });

  const { data, error } = await supabase
    .from('patient_treatments')
    .select(`
      *,
      treatments!inner(
        global_variables!inner(
          name
        )
      )
    `)
    .eq('patient_id', patientId)
    .is('end_date', null) // Optionally filter for currently active treatments
    .order('start_date', { ascending: false });

  if (error) {
    logger.error('Error fetching patient treatments:', { patientId, error });
    throw new Error('Failed to fetch patient treatments');
  }

  return data || [];
}

export async function addInitialPatientTreatmentsAction(
  userId: string,
  selectedTreatments: SelectedTreatment[] // Updated parameter type
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createClient();
  logger.info('Adding initial patient treatments', { userId, count: selectedTreatments.length });

  if (!userId || !selectedTreatments || selectedTreatments.length === 0) {
    logger.warn('Attempted to add initial treatments with invalid input', { userId, selectedTreatments });
    return { success: false, error: 'Invalid input provided.' };
  }

  try {
    // 1. Find or Create User Variables for each selected treatment
    const userVariableIds: { [treatmentId: string]: string } = {};
    const upsertPromises = selectedTreatments.map(async (treatment) => {
      const userVariableToUpsert: UserVariableInsert = {
        user_id: userId,
        global_variable_id: treatment.treatmentId,
        // id is generated by the database by default
      };

      logger.info('Upserting user_variable', { userId, global_variable_id: treatment.treatmentId });
      const { data, error } = await supabase
        .from('user_variables')
        .upsert(userVariableToUpsert, { onConflict: 'user_id, global_variable_id' })
        .select('id')
        .single(); // Expecting one record back

      if (error) {
        logger.error('Error upserting user_variable', { userId, global_variable_id: treatment.treatmentId, error });
        throw new Error(`Failed to ensure user variable for treatment ${treatment.treatmentName}.`);
      }
      if (!data?.id) {
        logger.error('User variable upsert did not return ID', { userId, global_variable_id: treatment.treatmentId });
        throw new Error(`Failed to get ID for user variable for treatment ${treatment.treatmentName}.`);
      }
      userVariableIds[treatment.treatmentId] = data.id;
      logger.info('Successfully upserted user_variable', { userId, global_variable_id: treatment.treatmentId, user_variable_id: data.id });
    });

    await Promise.all(upsertPromises);

    // 2. Prepare Patient Treatments for Insertion using the retrieved User Variable IDs
    const patientTreatmentsToInsert: Omit<PatientTreatmentInsert, 'id'>[] = selectedTreatments.map(treatment => {
      const userVariableId = userVariableIds[treatment.treatmentId];
      if (!userVariableId) {
         // This should ideally not happen if upsert succeeded
         logger.error('Could not find user_variable_id after upsert', { userId, treatmentId: treatment.treatmentId });
         throw new Error(`Internal error: Missing user variable ID for treatment ${treatment.treatmentName}.`);
      }
      return {
        patient_id: userId,
        treatment_id: treatment.treatmentId, // This remains the global_variable_id
        user_variable_id: userVariableId, // Use the ID from user_variables
        status: 'active',
        start_date: new Date().toISOString(),
      };
    });

    // 3. Perform Patient Treatment Insertion
    logger.info('Attempting to insert patient treatments', { userId, data: patientTreatmentsToInsert });
    const { data: insertedPatientTreatments, error: ptError } = await supabase
      .from('patient_treatments')
      .insert(patientTreatmentsToInsert)
      .select('id, treatment_id');

    if (ptError || !insertedPatientTreatments) {
      logger.error('Error inserting initial patient treatments:', { userId, error: ptError });
      console.error("Supabase Insert Error (patient_treatments):", JSON.stringify(ptError, null, 2));
      throw new Error(ptError?.message || 'Failed to save patient treatments.');
    }

    logger.info('Successfully inserted patient treatments', { userId, count: insertedPatientTreatments.length });

    // 4. Revalidation
    try {
      revalidatePath(`/patient`);
      revalidatePath(`/patient/treatments`);
      const uniqueTreatmentIds = [...new Set(selectedTreatments.map(t => t.treatmentId))];
      uniqueTreatmentIds.forEach(tId => {
        revalidatePath(`/treatments/${tId}`);
      });
    } catch (revalError) {
      logger.error('Error during revalidation after initial treatment add', { revalError, userId });
      // Don't fail the whole operation for revalidation error
    }

    logger.info('Successfully added initial patient treatments', { userId });
    return { success: true };

  } catch (error) {
    logger.error('Operation failed in addInitialPatientTreatmentsAction', { userId, error: error instanceof Error ? error.message : String(error) });
    return { success: false, error: error instanceof Error ? error.message : 'An unexpected error occurred.' };
  }
} 