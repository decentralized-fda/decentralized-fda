import { Pool, QueryResult } from 'pg';
import * as fs from 'fs/promises';
import * as path from 'path';
import * as dotenv from 'dotenv';
import type { Database } from '../lib/database.types'; // Adjust path if needed
/// <reference path="../lib/database.types.ts" />
// import type { Database } from '../lib/database.types'; // Adjust path if needed

// Load environment variables from .env file
dotenv.config({ path: path.resolve(__dirname, '../.env') }); // Adjust path to your .env file

type UnitRow = Database['public']['Tables']['units']['Row'];

const OUTPUT_PATH = path.resolve(__dirname, '../lib/constants/units.ts'); // Adjust path if needed

async function generateUnitConstants() {
  const dbUrl = process.env.DATABASE_URL;
  if (!dbUrl) {
    throw new Error('DATABASE_URL environment variable is not set.');
  }

  const pool = new Pool({
    connectionString: dbUrl,
    // Add SSL configuration if required for your Supabase connection
    // ssl: {
    //   rejectUnauthorized: false, // Or configure properly based on Supabase certs
    // },
  });

  let client;
  try {
    client = await pool.connect();
    console.log('Connected to database.');

    const result: QueryResult<UnitRow> = await client.query('SELECT * FROM public.units ORDER BY name');
    const units = result.rows;

    if (!units || units.length === 0) {
      console.warn('No units found in the database. Output file will be empty.');
    }

    console.log(`Found ${units.length} units.`);

    // Generate TypeScript code
    let tsCode = `// Generated by scripts/generate-constants.ts at ${new Date().toISOString()}\n`;
    tsCode += `// Do not edit this file manually, it will be overwritten.\n\n`;
    tsCode += `import type { Database } from '@/lib/database.types';\n\n`;
    tsCode += `type UnitRow = Database['public']['Tables']['units']['Row'];\n\n`;

    // Generate UNIT_IDS enum-like object
    tsCode += `export const UNIT_IDS = {\n`;
    units.forEach(unit => {
      const key = unit.name.toUpperCase().replace(/[^A-Z0-9_]/g, '_').replace(/_+/g, '_');
      tsCode += `  ${key}: '${unit.id}', // ${unit.name}\n`;
    });
    tsCode += `} as const;\n\n`;

    // Regenerate UNIT_IDS locally for use in the UNITS_DATA generation
    // This avoids the dependency issue in the previous version
    const localUnitIds: Record<string, string> = {}; 
    units.forEach(unit => {
      const key = unit.name.toUpperCase().replace(/[^A-Z0-9_]/g, '_').replace(/_+/g, '_');
      localUnitIds[key] = unit.id;
    });

    // Generate UNITS_DATA map
    tsCode += `export const UNITS_DATA: Record<string, UnitRow> = {\n`;
    units.forEach(unit => {
      const key = unit.name.toUpperCase().replace(/[^A-Z0-9_]/g, '_').replace(/_+/g, '_');
      const unitIdConstant = `UNIT_IDS.${key}`;

      // Create a temporary object to correctly format numbers
      const unitDataForJson = {
        ...unit,
        // Explicitly parse numeric fields
        conversion_factor: parseFloat(String(unit.conversion_factor)), 
        conversion_offset: parseFloat(String(unit.conversion_offset)),
      };

      // Check if the generated key exists in our local map
      if (localUnitIds[key] === unit.id) {
         // Use JSON.stringify but replace stringified numbers with actual numbers
         let unitJsonString = JSON.stringify(unitDataForJson, null, 2);
         // Use regex to remove quotes around numbers for the specific keys
         unitJsonString = unitJsonString.replace(/"(conversion_factor|conversion_offset)":\s*"(-?\d*\.?\d+)"/g, '"$1": $2');
         tsCode += `  [${unitIdConstant}]: ${unitJsonString},
`;
      } else {
          console.warn(`Mismatch or failed key generation for unit ID: ${unit.id}, Name: ${unit.name}, Generated Key: ${key}`);
          let unitJsonString = JSON.stringify(unitDataForJson, null, 2);
          unitJsonString = unitJsonString.replace(/"(conversion_factor|conversion_offset)":\s*"(-?\d*\.?\d+)"/g, '"$1": $2');
          tsCode += `  '${unit.id}': ${unitJsonString}, // Fallback key
`;
      }
    });
    tsCode += `};\n`;

    // Ensure the directory exists
    await fs.mkdir(path.dirname(OUTPUT_PATH), { recursive: true });

    // Write the file
    await fs.writeFile(OUTPUT_PATH, tsCode, 'utf8');
    console.log(`Successfully generated constants file at ${OUTPUT_PATH}`);

  } catch (error) {
    console.error('Error generating unit constants:', error);
    process.exit(1); // Exit with error code
  } finally {
    if (client) {
      client.release(); // Release the client back to the pool
    }
    await pool.end(); // Close the pool
    console.log('Database connection closed.');
  }
}

// Remove the IIFE pre-population logic as it's now handled within the main function
generateUnitConstants(); 